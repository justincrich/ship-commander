package logging

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/charmbracelet/log"
)

func TestNewCreatesJSONLogInHomeDirectory(t *testing.T) {
	home := t.TempDir()
	t.Setenv("HOME", home)

	logger, err := New(context.Background())
	if err != nil {
		t.Fatalf("new logger: %v", err)
	}
	t.Cleanup(func() {
		if closeErr := logger.Close(); closeErr != nil {
			t.Fatalf("close logger: %v", closeErr)
		}
	})

	logger.Logger.Info("test-entry", "key", "value")

	logPath := logger.Path()
	if !strings.HasPrefix(logPath, filepath.Join(home, ".sc3", "logs")) {
		t.Fatalf("log path = %q, want prefix %q", logPath, filepath.Join(home, ".sc3", "logs"))
	}

	// #nosec G304 -- logPath is generated by logger.New() under temp HOME.
	content, err := os.ReadFile(logPath)
	if err != nil {
		t.Fatalf("read log file: %v", err)
	}
	if !strings.Contains(string(content), "\"msg\":\"test-entry\"") {
		t.Fatalf("log file does not contain JSON message entry: %s", string(content))
	}
}

func TestNewIncludesRunTraceAndSpanFields(t *testing.T) {
	home := t.TempDir()
	t.Setenv("HOME", home)

	logger, err := New(
		context.Background(),
		WithRunID("run-123"),
		WithTraceID("trace-abc"),
		WithSpanID("span-def"),
	)
	if err != nil {
		t.Fatalf("new logger: %v", err)
	}
	t.Cleanup(func() {
		if closeErr := logger.Close(); closeErr != nil {
			t.Fatalf("close logger: %v", closeErr)
		}
	})

	logger.Logger.Info("correlated-entry")

	records := readLogRecords(t, logger.Path())
	record := findRecordByMessage(t, records, "correlated-entry")

	if got := asString(record["run_id"]); got != "run-123" {
		t.Fatalf("run_id = %q, want %q", got, "run-123")
	}
	if got := asString(record["trace_id"]); got != "trace-abc" {
		t.Fatalf("trace_id = %q, want %q", got, "trace-abc")
	}
	if got := asString(record["span_id"]); got != "span-def" {
		t.Fatalf("span_id = %q, want %q", got, "span-def")
	}
}

func TestWithCorrelationHelpersUpdateSubsequentRecords(t *testing.T) {
	home := t.TempDir()
	t.Setenv("HOME", home)

	logger, err := New(context.Background())
	if err != nil {
		t.Fatalf("new logger: %v", err)
	}
	t.Cleanup(func() {
		if closeErr := logger.Close(); closeErr != nil {
			t.Fatalf("close logger: %v", closeErr)
		}
	})

	logger.WithRunID("run-456").WithTraceID("trace-xyz").WithSpanID("span-uvw")
	logger.Logger.Info("mutated-correlation-entry")

	records := readLogRecords(t, logger.Path())
	record := findRecordByMessage(t, records, "mutated-correlation-entry")

	if got := asString(record["run_id"]); got != "run-456" {
		t.Fatalf("run_id = %q, want %q", got, "run-456")
	}
	if got := asString(record["trace_id"]); got != "trace-xyz" {
		t.Fatalf("trace_id = %q, want %q", got, "trace-xyz")
	}
	if got := asString(record["span_id"]); got != "span-uvw" {
		t.Fatalf("span_id = %q, want %q", got, "span-uvw")
	}
}

func TestNewPrunesOldLogsByRetentionLimit(t *testing.T) {
	home := t.TempDir()
	t.Setenv("HOME", home)
	logDir := filepath.Join(home, ".sc3", "logs")
	if err := os.MkdirAll(logDir, 0o750); err != nil {
		t.Fatalf("mkdir log dir: %v", err)
	}

	base := time.Now().Add(-10 * time.Minute)
	for i := 0; i < 6; i++ {
		path := filepath.Join(logDir, fmt.Sprintf("sc3-old-%d.log", i))
		if err := os.WriteFile(path, []byte("old"), 0o600); err != nil {
			t.Fatalf("write %s: %v", path, err)
		}
		mod := base.Add(time.Duration(i) * time.Minute)
		if err := os.Chtimes(path, mod, mod); err != nil {
			t.Fatalf("chtimes %s: %v", path, err)
		}
	}

	logger, err := New(context.Background(), WithMaxFiles(3))
	if err != nil {
		t.Fatalf("new logger: %v", err)
	}
	t.Cleanup(func() {
		if closeErr := logger.Close(); closeErr != nil {
			t.Fatalf("close logger: %v", closeErr)
		}
	})

	files, err := filepath.Glob(filepath.Join(logDir, "sc3-*"))
	if err != nil {
		t.Fatalf("glob logs: %v", err)
	}
	if len(files) != 3 {
		t.Fatalf("log file count = %d, want 3 retained files", len(files))
	}
	if _, err := os.Stat(filepath.Join(logDir, "sc3-old-0.log")); err == nil {
		t.Fatal("expected oldest historical log to be pruned")
	}
}

func TestNewRotatesWhenMaxSizeExceeded(t *testing.T) {
	home := t.TempDir()
	t.Setenv("HOME", home)

	logger, err := New(context.Background(), WithMaxSizeBytes(300), WithMaxFiles(3))
	if err != nil {
		t.Fatalf("new logger: %v", err)
	}
	t.Cleanup(func() {
		if closeErr := logger.Close(); closeErr != nil {
			t.Fatalf("close logger: %v", closeErr)
		}
	})

	payload := strings.Repeat("x", 220)
	for i := 0; i < 12; i++ {
		logger.Logger.Info("rotation-entry", "payload", payload)
	}

	if _, err := os.Stat(logger.Path() + ".1"); err != nil {
		t.Fatalf("expected rotated backup file: %v", err)
	}
	files, err := filepath.Glob(logger.Path() + "*")
	if err != nil {
		t.Fatalf("glob rotated files: %v", err)
	}
	if len(files) > 3 {
		t.Fatalf("rotated file count = %d, want <= 3", len(files))
	}
}

func TestNewConsoleDebugWritesToStderr(t *testing.T) {
	home := t.TempDir()
	t.Setenv("HOME", home)

	var console bytes.Buffer

	logger, err := New(
		context.Background(),
		WithConsoleStderr(true),
		WithConsoleWriter(&console),
		WithLevel(log.DebugLevel),
	)
	if err != nil {
		t.Fatalf("new logger: %v", err)
	}
	t.Cleanup(func() {
		if closeErr := logger.Close(); closeErr != nil {
			t.Fatalf("close logger: %v", closeErr)
		}
	})

	logger.Logger.Debug("console-debug-entry")
	if !strings.Contains(console.String(), "console-debug-entry") {
		t.Fatalf("expected debug log in stderr mirror, got: %q", console.String())
	}
}

func readLogRecords(t *testing.T, path string) []map[string]any {
	t.Helper()
	// #nosec G304 -- path comes from logger.Path() in test setup.
	content, err := os.ReadFile(path)
	if err != nil {
		t.Fatalf("read log file: %v", err)
	}

	lines := strings.Split(strings.TrimSpace(string(content)), "\n")
	records := make([]map[string]any, 0, len(lines))
	for _, line := range lines {
		if strings.TrimSpace(line) == "" {
			continue
		}
		record := map[string]any{}
		if err := json.Unmarshal([]byte(line), &record); err != nil {
			t.Fatalf("unmarshal log line %q: %v", line, err)
		}
		records = append(records, record)
	}
	return records
}

func findRecordByMessage(t *testing.T, records []map[string]any, message string) map[string]any {
	t.Helper()
	for _, record := range records {
		if asString(record["msg"]) == message {
			return record
		}
	}
	t.Fatalf("record with msg %q not found", message)
	return nil
}

func asString(value any) string {
	text, ok := value.(string)
	if !ok {
		return ""
	}
	return text
}
